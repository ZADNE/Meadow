/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <Meadow/terrain/external_shaders/float_hash.glsl>
#include <Meadow/terrain/shaders/ground.glsl>
#include <Meadow/terrain/shaders/culling.glsl>
const uint TerrainUB_BINDING = 0;
#include <Meadow/terrain/shaders/TerrainUB.glsl>
const uint BladeSB_BINDING = 1;
#include <Meadow/terrain/shaders/BladeSB.glsl>

layout (local_size_x = 64,
        local_size_y = 1,
        local_size_z = 1
) in;

shared uint s_bladeCount;
shared uint s_bladeBaseIndex;

float windStrength(vec2 pos, float seed){
    float strength = 0.25;
    float s = 0.25;
    pos *= 0.0078125; // 1/128
    for (int i = 0; i < 3; ++i){
        strength += snoise(pos, seed) * s;
        pos *= 2.0;
        s *= 0.5;
    }
    return strength;
}

void main() {
    // Initialize
    const bool  leader = gl_LocalInvocationIndex == 0;
    const uint  workGroupIndex = gl_WorkGroupID.y * k_mapGridSize.x + gl_WorkGroupID.x;
    const uint  globalInvocationIndex = workGroupIndex * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
    const float seed = u_terrain.seed;
    const float seededId = globalInvocationIndex + seed * 4787.0;
    if (leader){
        s_bladeCount = 0;
    }
    barrier();

    // Calculate position, rotation, etc
    const vec2  offsetInTile = hash21(seededId);
    const vec2  pos2D = (vec2(gl_WorkGroupID.xy) + offsetInTile - k_mapGridHalfSize) * k_mapTileSize;
    const vec3  pos = vec3(pos2D.x, groundHeight(pos2D, seed), pos2D.y);
    const float rotRad = hash11(seededId) * 6.28318530718;
    const vec2  facing = vec2(cos(rotRad), sin(rotRad));
    const float wind = windStrength(pos2D + u_terrain.windOffset, seed);
    const vec2  tipOffset = normalize(vec2(0.1875, 0.5625 - wind));

    // Test if blade is inside frustum
    uint bladeIndexOffset = -1; // -1 means that it is not visible
    {
        vec4 p = vec4(pos, 1.0);
        ivec3 rootCull = frustumPlaneSigns(u_terrain.cullingProjViewMat * p);
        p.xyz += vec3(tipOffset.x * facing.x, -tipOffset.y, tipOffset.x * facing.y);
        ivec3 tipCull  = frustumPlaneSigns(u_terrain.cullingProjViewMat * p);

        if (!shouldBeCulled(rootCull, tipCull)){
            bladeIndexOffset = atomicAdd(s_bladeCount, 1);
        }
    }
    barrier();

    // Get global index
    if (leader){
        s_bladeBaseIndex = atomicAdd(b_blade.command.instanceCount, s_bladeCount);
    }
    barrier();

    // Output visible blades
    if (bladeIndexOffset != -1){
        const uint index = s_bladeBaseIndex + bladeIndexOffset;
        if (index < b_blade.blades.length()){
            b_blade.blades[index] = Blade(
                vec4(pos, hash11(rotRad)),
                tipOffset,
                packSnorm2x16(facing),
                max(wind - 0.125, 0.0));
        }
    }
}

/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <Meadow/grass/shaders/height.glsl>
const uint GrassUB_BINDING = 0;
#include <Meadow/grass/shaders/GrassUB.glsl>
const uint StalkSB_BINDING = 1;
#include <Meadow/grass/shaders/StalkSB.glsl>

layout (local_size_x = 2,
        local_size_y = 16,
        local_size_z = 1
) in;

shared uint s_stalkCount;
shared uint s_stalkBaseIndex;

void main() {
    // Initialize
    const bool leader = gl_LocalInvocationIndex == 0;
    if (leader){
        s_stalkCount = 0;
    }
    barrier();

    // Count visible stalks
    vec3 stalkPos;
    uint stalkIndexOffset = -1; // -1 means that it is not visible
    if (gl_LocalInvocationID.y == 0){
        vec2 pos2D = (vec2(gl_WorkGroupID.xy) - k_mapGridHalfSize) * k_mapTileSize
                    + gl_LocalInvocationID.x;
        float h = height(pos2D, u_grass.seed);
        stalkPos = vec3(pos2D.x, h, pos2D.y);

        // Test if stalk is inside frustum
        vec4 p = u_grass.cullingProjViewMat * vec4(stalkPos, 1.0);
        p.w *= 1.125;
        bool inFrustum = 
            (p.x > -p.w) && (p.x < p.w) &&
            (p.y > -p.w) && (p.y < p.w);

        if (inFrustum){
            stalkIndexOffset = atomicAdd(s_stalkCount, 1);
        }
    }
    barrier();

    // Get global index
    if (leader){
        s_stalkBaseIndex = atomicAdd(b_stalk.command.instanceCount, s_stalkCount);
    }
    barrier();

    // Output stalks
    if (stalkIndexOffset != -1){
        b_stalk.stalks[s_stalkBaseIndex + stalkIndexOffset] =
            Stalk(vec4(stalkPos, 1.0), vec2(0), vec2(0));
    }
}
